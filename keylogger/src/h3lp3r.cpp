#include "h3lp3r.h"

#include <cstring>
#include <unistd.h>
#include <csignal>
#include <errno.h>
#include <iostream>
#include <ostream>
#include <curl/curl.h>
#include <fstream>

int writeAll(const int fd, const char* str) {
    ssize_t bytesWritten = 0;
    size_t bytesToWrite = strlen(str);

    do {
        bytesWritten = write(fd, str, bytesToWrite);
        if (bytesWritten == -1) {
            return 0;
        }
        bytesToWrite -= bytesWritten;
        str += bytesWritten;
    } while (bytesToWrite > 0);
    return 1;
}

void safeWriteAll(const int fd, const char* str, const int keyboard) {
    struct sigaction new_action{}, old_action{};
    new_action.sa_handler = SIG_IGN;
    sigemptyset(&new_action.sa_mask);
    new_action.sa_flags = 0;

    sigaction(SIGPIPE, &new_action, &old_action);
    if (!writeAll(fd, str)) {
        close(fd);
        close(keyboard);
        std::cerr << "Error from helper: " << strerror(errno) << std::endl;
        exit(1);
    }
    sigaction(SIGPIPE, &old_action, nullptr);
}

void printUsageAndExit(char* appName) {
    std::cout << "Usage: " << appName << " output-file-name" << std::endl;
    exit(1);
}

size_t writeCallback(void* contents, const size_t size, const size_t nmemb, serverResponse* response) {
    const size_t totalSize = size * nmemb; // `nmemb` is number of data elements; `size` is the size of each data element
    const std::string data(static_cast<char*>(contents), totalSize);
    response->action0 = data[0] - '0'; // convert character to int
    response->action1 = data[1] - '0';
    response->action2 = data[2] - '0';
    response->action3 = data[3] - '0';
    response->action4 = data[4] - '0';

    return totalSize;
}

void makeRequest(const std::string& url, serverResponse& response) {
    CURL* curl = curl_easy_init();

    if (curl) {
        curl_easy_setopt(curl, CURLOPT_URL, url.c_str()); // Tell the curl instance what URL to curl
        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L); // Follow redirects
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeCallback); // Tell curl instance what write function to use
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response); // Tell curl instance what data to write
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L); // don't verify peer (self-signed cert)
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L); // don't verify host (self-signed cert)

        CURLcode res = curl_easy_perform(curl); // Actually make the request

        if (res != CURLE_OK) {
            std::cerr << "cURL failed: " << curl_easy_strerror(res) << std::endl;
        } else {
            std::cout << "Response received." << std::endl;
        }

        curl_easy_cleanup(curl);
    } else {
        std::cerr << "Failed to initialize cURL." << std::endl;
    }
}

size_t readCallback(void* ptr, size_t size, size_t nmemb, void* userdata) {
    std::ifstream* file = static_cast<std::ifstream*>(userdata);
    if (!file->is_open()) {
        return 0;
    }

    file->read(static_cast<char*>(ptr), static_cast<std::streamsize>(size * nmemb));
    return static_cast<size_t>(file->gcount());
}

bool sendFile(const std::string& url, const std::string& filePath) {
    CURL* curl = curl_easy_init();
    if (!curl) {
        std::cerr << "Failed to initialize cURL." << std::endl;
        return false;
    }

    std::ifstream file(filePath, std::ios::binary);
    if (!file.is_open()) {
        std::cerr << "Failed to open file: " << filePath << std::endl;
        curl_easy_cleanup(curl);
        return false;
    }

    struct curl_httppost* post = nullptr;
    struct curl_httppost* last = nullptr;

    curl_formadd(&post, &last,
        CURLFORM_COPYNAME, "file",  // form field name corresponding to the express endpoint
        CURLFORM_FILE, filePath.c_str(),
        CURLFORM_END);

    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
    curl_easy_setopt(curl, CURLOPT_HTTPPOST, post);
    curl_easy_setopt(curl, CURLOPT_READDATA, &file);
    curl_easy_setopt(curl, CURLOPT_READFUNCTION, readCallback);
    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L); // don't verify peer (self-signed cert)
    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L); // don't verify host (self-signed cert)

    CURLcode res = curl_easy_perform(curl);
    if (res != CURLE_OK) {
        std::cerr << "cURL perform failed: " << curl_easy_strerror(res) << std::endl;
        curl_easy_cleanup(curl);
        curl_formfree(post);
        return false;
    }

    curl_easy_cleanup(curl);
    curl_formfree(post);
    return true;
}
